//对象池一般不支持拷贝构造，拷贝构造一份对象，相当于又有一个指针指向了这个内存池，如果两个对象都去申请的话，拿到的是同一块内存，是会出现问题的
#pragma once

//注意：模板不支持分离编译
template<class T, size_t N_Obj = 20>
class ObjectPool
{
public:
	ObjectPool() = default;//编译器自己生成一个构造函数
	//防拷贝
	ObjectPool(const ObjectPool<T>&) = delete;//拷贝构造
	ObjectPool<T>& operator=(const ObjectPool<T>&) = delete;//operator赋值

	template<class INIT_T>//类模板的模板成员函数
	T* New(const INIT_T& x = INIT_T())//在new的时候就初始化
	{
		T* obj = nullptr;
		if (_freelist != nullptr)//不为空则有内存可以直接用
		{
			//内存块的头四个字节存下一块的地址
			void* next = *((void**)_freelist);//类型决定看多少所以强转为(int*)
			obj = (T*)_freelist;
			_freelist = next;
		}
		else//没有内存，需要向对象池申请
		{
			if (_start == _finish)//对象池没有内存，向系统申请
			{
				_start = (char*)malloc(sizeof(T)*N_Obj);
				
				//new失败，抛异常
				//_start = nullptr;
				/*if (_start == nullptr)
				{
					throw std::bad_alloc();
				}
				_finish = _start + sizeof(T)*N_Obj;
			}*/

			//内存池有内存,直接切着用
			obj = (T*)_start;
			_start += sizeof(T);
		}
		new(obj)T(x);//new的定位表达式，对已有空间进行初始化
		return obj;
	}
	void Delete(T* ptr)
	{
		ptr->~T();//显示调用析构函数，否则内存泄漏
		*(void**)ptr= _freelist;
		_freelist = ptr;
	}

private:
	char* _start=nullptr;//对象池一开始什么也没有，给定缺省值自动初始化
	char* _finish = nullptr;//char*类型＋1正好加一个字节

	void* _freelist = nullptr;
};

void TestObjectPool()
{
	ObjectPool<std::string> pool;
	std::string* p1 = pool.New("111");
	std::string* p2 = pool.New("222");
	cout << p1 << endl;
	cout << p2 << endl;
	pool.Delete(p1);
	pool.Delete(p2);

	std::string* p3 = pool.New("333");
	std::string* p4 = pool.New("444");
	std::string* p5 = pool.New("555");
	cout << p3 << endl;
	cout << p4 << endl;
	cout << p5 << endl;
}
#include <vector>
#include <time.h>

void BenchMark()//测试性能(绩效标杆)在release下
{
	size_t n = 10000;
	
	std::vector<std::string*> v1;
	v1.reserve(n);
	size_t begin1 = clock();
	for (size_t i = 0; i < n; ++i)
	{
		v1.push_back(new std::string);
	}
	for (size_t i = 0; i < n; ++i)
	{
		free(v1[i]);
	}
	size_t end1 = clock();


	std::vector<std::string*> v2;
	v2.reserve(n); 
	size_t begin2 = clock();
	ObjectPool<std::string> pool;
	for (size_t i = 0; i < n; ++i)
	{
		v2.push_back(pool.New(""));
	}
	for (size_t i = 0; i < n; ++i)
	{
		pool.Delete(v2[i]);
	}
	size_t end2 = clock();

	cout << end1 - begin1 << endl;
	cout << end2 - begin2 << endl;

}